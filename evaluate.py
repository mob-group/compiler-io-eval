import sys
import utilities
import os.path
from code_gen import CReference, AnyCType, ScalarCType, ArrayCType, VoidCType, CParameter
from examples import ExampleCollection, AnyCValue, SomeCValue, ArrayCValue, ScalarCValue
from dataclasses import dataclass
from typing import *

ParameterExample = Tuple[CParameter, SomeCValue]
ReturnExample = Tuple[AnyCType, AnyCValue]


@dataclass
class ExampleInstance:
    """
    A wrapper class for a single example

    Contains all input/output examples and their mappings to parameters (or return type).
    """
    inputs: List[ParameterExample]
    value: ReturnExample
    outputs: List[ParameterExample]

    def get_stdin(self) -> str:
        """
        Builds the input expected by the program when this example is being tested

        :return: the stdin for this example
        """
        stdin = []
        for param, val in self.inputs:
            stdin.append(ExampleInstance.describe(val, param.c_type))

        return '\n'.join(stdin)

    def get_args(self) -> str:
        """
        Builds the arguments for the program when this example is being tested

        The arguments are the sizes of any unsized arrays
        (at this point only strings are handled correctly).
        This size is determined here by checking the inputs and outputs for any unsized parameters,
        and asserting that the parameter only needs to be large enough to accommodate the biggest value.

        For example: if the function took parameter :code:`char *s`, and this parameter was an output,
        then this function would look at the input and output values for this parameter
        (e.g. "hi" -> "hello")
        and use this to determine the required space in the array.
        Here *s* has to accommodate both "hi" and "hello", so requires 6 bytes to be allocated.
        :return:
        """
        # doing outputs first since then inputs can be done in one pass
        sizes = {param.name: len(val) for param, val in self.outputs
                 if isinstance(param.c_type, ArrayCType) and param.c_type.size is None}

        args = []
        for param, val in self.inputs:
            if param.name in sizes:
                args += str(1 + max(sizes[param.name], len(val)))
            elif isinstance(param.c_type, ArrayCType) and param.c_type.size is None:
                args += str(1+len(val))

        return ' '.join(args)

    @staticmethod
    def parse(desc: str, c_type: AnyCType) -> AnyCValue:
        """
        Parse a value written by the reference function and parse it into the value it represents

        For more detail on this format check the :code:`printf_template` methods of ScalarCType and ArrayCType.

        :param desc: the line of output given by the function denoting a value
        :param c_type: the expected type of the value
        :return: the value parsed from the string
        """
        def parse_scalar(description: str, c_type: ScalarCType) -> ScalarCValue:
            description = description.strip()
            if c_type == ScalarCType.Int or c_type == ScalarCType.Bool:
                return int(description)
            elif c_type == ScalarCType.Float or c_type == ScalarCType.Double:
                return float(description)
            elif c_type == ScalarCType.Char:
                return chr(int(description))

        def parse_array(description: str, c_type: ArrayCType) -> ArrayCValue:
            description = description.strip()
            if description == "":
                return []

            return [parse_scalar(chunk, c_type.scalar_c_type) for chunk in description.split(" ")]

        if isinstance(c_type, ScalarCType):
            return parse_scalar(desc, c_type)
        elif isinstance(c_type, ArrayCType):
            parsed = parse_array(desc, c_type)
            if c_type.scalar_c_type == ScalarCType.Char:
                return "".join(parsed)

            return parsed
        else:
            return None

    def check_output(self, stdout: str) -> bool:
        """
        Tests the output generated by running the reference against the current example

        Writes all issues to stderr

        :param stdout: the output produced when the reference is run
        :return: :code:`True` if and only if all values matched
        """
        pass_test = True

        stdout = [line.strip() for line in stdout.splitlines() if line.strip()]

        ret_type, ret_val = self.value
        if not isinstance(ret_type, VoidCType):
            ex_val = ExampleInstance.parse(stdout[0], ret_type)
            if ret_val != ex_val:
                sys.stderr.write(f"return value does not match! ({ret_val} vs. {ex_val})\n")
                pass_test = False

            stdout = stdout[1:]

        assert len(stdout) == len(self.outputs)
        for line, (param, value) in zip(stdout, self.outputs):
            ex_value = ExampleInstance.parse(line, param.c_type)
            if value != ExampleInstance.parse(line, param.c_type):
                sys.stderr.write(f"output does not match! ({value} vs. {ex_value})\n")
                pass_test = False

        return pass_test

    def __str__(self):
        s = ["==== INPUTS ===="]
        for param, val in self.inputs:
            s.append(f"{param.c_repr} = {val}")

        s.append("==== RETURN ====")
        s.append(f"{self.value[0].c_repr} {self.value[1]}")

        s.append("=== OUTPUTS ====")
        for param, val in self.outputs:
            s.append(f"{param.c_repr} = {val}")

        s.append("================")

        return '\n'.join(s)

    @staticmethod
    def describe(val: AnyCValue, c_type: AnyCType) -> str:
        """
        Convert a value to the format readable by the reference function

        Inverse of :code:`parse`

        :param val: the value to format correctly
        :param c_type: the type of the value
        :return: the formatted string
        """
        if isinstance(c_type, ScalarCType) and c_type == ScalarCType.Char:
            return str(ord(val))
        elif isinstance(c_type, ScalarCType):
            return str(val)
        elif c_type.scalar_c_type == ScalarCType.Char:
            return ' '.join([str(ord(c)) for c in val] + ["0"])
        else:
            return ' '.join(str(v) for v in val)


@dataclass
class Evaluator:
    """
    Contains a reference and a bunch of examples, and allows them to be checked.

    All inputs/outputs should be in the order that the reference is expecting.
    This means the inputs must be in the read-order, and outputs must be ordered correctly too.
    """
    reference: CReference
    inputs: List[List[SomeCValue]]
    values: List[AnyCValue]
    outputs: List[List[SomeCValue]]

    @staticmethod
    def build_from(ref: CReference, examples: ExampleCollection):
        """
        Generate an evaluator from a reference and examples

        Note that the examples are transposed into a "stretched out" form,
        where the examples for each input, output, and the return form are all in one list.

        This will be used to allow some manipulation of examples, such as swapping parameters if the names don't line up
        or predicting sizes of arrays if they are not given.

        :param ref: the reference function
        :param examples: examples for that reference
        :return:
        """
        inp_vals, example_returns, outp_vals = examples.transposed_examples

        example_inputs = {inp.name: (inp.type, inp_val) for inp, inp_val in zip(examples.inputs, inp_vals)}
        example_outputs = {outp.name: (outp.type, outp_val) for outp, outp_val in zip(examples.outputs, outp_vals)}

        # this is where the smart size inference etc. can come in
        inputs = []
        for param in ref.read_order:
            if example_inputs.get(param.name) is not None:
                c_type, values = example_inputs[param.name]

                if CReference.get_c_type(c_type) != param.c_type:
                    raise Exception(
                        f"incorrect parameter for {param.name} (found {c_type}, expected {param.c_type.c_repr})")

                inputs.append(values)
            else:
                raise Exception(f"parameter {param.name} could not be found")

        if CReference.get_c_type(examples.ret_type) != ref.c_type:
            raise Exception(f"incorrect return type (found {examples.ret_type}, expected {ref.c_type.c_repr})")
        returns = example_returns

        outputs = []
        for param in ref.outputs:
            if example_outputs.get(param.name) is not None:
                c_type, values = example_outputs[param.name]

                if CReference.get_c_type(c_type) != param.c_type:
                    raise Exception(
                        f"incorrect output parameter for {param.name} (found {c_type}, expected {param.c_type.c_repr})")

                outputs.append(values)
            else:
                raise Exception(f"output parameter {param.name} could not be found")

        return Evaluator(ref, inputs, returns, outputs)

    def next_example(self) -> Generator[ExampleInstance, None, None]:
        """
        Returns a generator used to squash the internal representation

        Since we want a full example (i.e. all parameters and return) to operate with the examples must be transposed.
        This is as easy as taking a "slice" across the examples,
        picking one value from all inputs, outputs and the return.
        """
        # size of return values is always equal to number of inputs, so safe to use for all
        for i in range(len(self.values)):
            inputs = [(param, inps[i]) for param, inps in zip(self.reference.read_order, self.inputs)]
            ret = (self.reference.c_type, self.values[i])
            outputs = [(param, outps[i]) for param, outps in zip(self.reference.outputs, self.outputs)]

            yield ExampleInstance(inputs, ret, outputs)

    def run(self, executable: str, example: ExampleInstance) -> str:
        """
        Runs a given example on the reference function

        :param executable: the file containing the reference executable
        :param example: the example to run on the reference
        :return: the output of that function
        """
        args = example.get_args()
        stdin = example.get_stdin()

        stdout, stderr = utilities.run_command(f"./{executable} {args}", stdin=stdin)

        if stderr:
            print(stderr)

        return stdout

    def evaluate(self) -> Tuple[int, int]:
        """
        Compiles and runs a reference function on the stored examples

        :return: (no. of successful runs, no. of failed runs)
        """
        exe = self.reference.compile(cleanup=False)
        success = 0
        failure = 0

        for example in self.next_example():
            stdout = self.run(exe, example)
            if example.check_output(stdout):
                success += 1
            else:
                failure += 1

        return success, failure


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("program", help="the reference program to evaluate")
    parser.add_argument("-p", "--program-path", help="the path to the reference program", default=".")

    parser.add_argument("examples", help="the file containing examples")
    parser.add_argument("-P", "--example-path", help="path to examples directory", default=".")

    args = parser.parse_args()

    ref = CReference.parse(args.program, args.program_path)
    exs = ExampleCollection.from_file(os.path.join(args.example_path, args.examples))

    evaluator = Evaluator.build_from(ref, exs)

    success, failure = evaluator.evaluate()
    print(f"ran with {success}/{success + failure} successes")
